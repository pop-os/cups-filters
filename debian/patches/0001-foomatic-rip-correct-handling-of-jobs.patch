From: JaiLuthra1 <luthrajaiji@gmail.com>
Date: Mon, 24 Feb 2020 17:37:40 +0530
Subject: foomatic-rip: correct handling of jobs

---
 filter/foomatic-rip/foomaticrip.c | 73 ++++++++++++++++++++++++++++++++++++++-
 filter/foomatic-rip/pdf.c         |  2 +-
 filter/foomatic-rip/pdf.h         |  1 +
 filter/foomatic-rip/postscript.c  |  8 -----
 4 files changed, 74 insertions(+), 10 deletions(-)

diff --git a/filter/foomatic-rip/foomaticrip.c b/filter/foomatic-rip/foomaticrip.c
index 73ef28c..ac248c0 100644
--- a/filter/foomatic-rip/foomaticrip.c
+++ b/filter/foomatic-rip/foomaticrip.c
@@ -668,6 +668,16 @@ int print_file(const char *filename, int convert)
                             "Couldn't dup stdout of pdf-to-ps\n");
 
                 clearerr(stdin);
+                int pagecount = pdf_count_pages(filename);
+                _log("File contains %d pages.\n", pagecount);
+                if (pagecount < 0) {
+                    _log("Unexpected page_count\n");
+                    return 0;
+                }
+                if (pagecount == 0) {
+                  _log("No pages left, outputting empty file.\n");
+                  return 1;
+                }
                 ret = print_file("<STDIN>", 0);
 
                 wait_for_process(renderer_pid);
@@ -687,7 +697,68 @@ int print_file(const char *filename, int convert)
         case PS_FILE:
             _log("Filetype: PostScript\n");
             if (file == stdin)
-                return print_ps(stdin, buf, n, filename);
+            {
+                if (convert)
+                {
+                    int fd;
+                    FILE *tmpfile;
+                    char tmpfilename[4096];
+
+                    snprintf(tmpfilename, PATH_MAX, "%s/foomatic-XXXXXX", temp_dir());
+                    fd = mkstemp(tmpfilename);
+                    if (fd < 0) {
+                        _log("Could not create temporary file: %s\n", strerror(errno));
+                        return EXIT_PRNERR_NORETRY_BAD_SETTINGS;
+                    }
+
+                    if (write(fd,buf,n) != n) {
+                        _log("ERROR: Can't copy stdin to temporary file\n");
+                        close(fd);
+                    }
+                    /* copy stdin to the tmp file */
+                    while ((n = read(0,buf,BUFSIZ)) > 0) {
+                        if (write(fd,buf,n) != n) {
+                            _log("ERROR: Can't copy stdin to temporary file\n");
+                            close(fd);
+                        }
+                    }
+                    if (lseek(fd,0,SEEK_SET) < 0) {
+                        _log("ERROR: Can't rewind temporary file\n");
+                        close(fd);
+                    }
+                    FILE *fp;
+
+                    if ((fp = fdopen(fd,"rb")) == 0) {
+                        _log("ERROR: Can't fdopen temporary file\n");
+                        close(fd);
+                    }
+                    char gscommand[65536];
+                    char output[31] = "";
+                    int pagecount;
+                    size_t bytes;
+                    filename = strdup(tmpfilename);
+                    snprintf(gscommand, 65536, "%s -q -dNOPAUSE -dBATCH -sDEVICE=bbox %s 2>&1 | grep -c HiResBoundingBox",
+                            CUPS_GHOSTSCRIPT, filename);
+                    FILE *pd = popen(gscommand, "r");
+                    bytes = fread(output, 1, 31, pd);
+                    pclose(pd);
+
+                    if (bytes <= 0 || sscanf(output, "%d", &pagecount) < 1)
+                    pagecount = -1;
+                    _log("File contains %d pages.\n", pagecount);
+                    if (pagecount < 0) {
+                        _log("Unexpected page_count\n");
+                        return 0;
+                    }
+                    if (pagecount == 0) {
+                        _log("No pages left, outputting empty file.\n");
+                        return 1;
+                    }
+                    return print_ps(fp, NULL, 0, filename);
+                }
+                else
+                    return print_ps(stdin, buf, n, filename);
+            }
             else
                 return print_ps(file, NULL, 0, filename);
 
diff --git a/filter/foomatic-rip/pdf.c b/filter/foomatic-rip/pdf.c
index 1631f96..7364a73 100644
--- a/filter/foomatic-rip/pdf.c
+++ b/filter/foomatic-rip/pdf.c
@@ -39,7 +39,7 @@
 static int wait_for_renderer();
 
 
-static int pdf_count_pages(const char *filename)
+int pdf_count_pages(const char *filename)
 {
     char gscommand[CMDLINE_MAX];
     char output[63] = "";
diff --git a/filter/foomatic-rip/pdf.h b/filter/foomatic-rip/pdf.h
index c9472a0..07e2f32 100644
--- a/filter/foomatic-rip/pdf.h
+++ b/filter/foomatic-rip/pdf.h
@@ -25,6 +25,7 @@
 #define pdf_h
 
 int print_pdf(FILE *s, const char *alreadyread, size_t len, const char *filename, size_t startpos);
+int pdf_count_pages(const char *filemame);
 
 #endif
 
diff --git a/filter/foomatic-rip/postscript.c b/filter/foomatic-rip/postscript.c
index 8b6f0ad..f0ddf01 100644
--- a/filter/foomatic-rip/postscript.c
+++ b/filter/foomatic-rip/postscript.c
@@ -322,7 +322,6 @@ void _print_ps(stream_t *stream)
     pid_t rendererpid = 0;
     FILE *rendererhandle = NULL;
 
-    int empty = 1;
     int retval;
 
     dstr_t *tmp = create_dstr();
@@ -1010,7 +1009,6 @@ void _print_ps(stream_t *stream)
                         /* No renderer running, start it */
                         dstrcpy(tmp, psheader->data);
                         dstrcat(tmp, psfifo->data);
-                        empty = 0;
                         get_renderer_handle(tmp, &rendererhandle, &rendererpid);
                         /* psfifo is sent out, flush it */
                         dstrclear(psfifo);
@@ -1075,12 +1073,6 @@ void _print_ps(stream_t *stream)
 
     } while ((maxlines == 0 || linect < maxlines) && more_stuff != 0);
 
-    if (empty)
-    {
-        _log("No pages left, outputting empty file.\n");
-        return;
-    }
-
     /* Some buffer still containing data? Send it out to the renderer */
     if (more_stuff || inheader || !isempty(psfifo->data)) {
         /* Flush psfifo and send the remaining data to the renderer, this
